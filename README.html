<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8"/>
</head>
<body>
<h1 id="progresspiesvg">progresspieSVG</h1>

<p>jQuery plug-in for dynamically rendering a pie or circle diagram comparable to a progress bar, depicting a progress, countdown, percent value or similar.</p>

<p><a href="http://www.isg-software.de/progresspie/indexe.html">Project home page</a></p>

<h2 id="whatisthis">What is this?</h2>

<p>This software module contains a <a href="https://jquery.com">jQuery</a> plug-in for drawing a partially filled circle (pie-chart with only one slice of the pie) for visualizing a single value between 0% and 100% inclusive, i.e. a kind of progress bar, but not in form of a bar but of a pie. The graphic is rendered inside a web page as SVG. In difference to e.g. the HTML <code>canvas</code> element, SVGs are scalable and render sharply on high resolution displays with device-pixel-ratio &gt; 1 (e.g. Apple&#8217;s “retina displays”).</p>

<p>As the name suggests, this component may be used to display a progress, starting at 0%, incrementing until 100% are reached. For this purpose the graphic may be dynamically updated (or, more precisely, replaced). </p>

<p>But just like progress bars these pies may actually be used to depict <em>any</em> percentual value, including static ones like e.g. percents of points achieved in a test. Mainly for this purpose, the pie may be dynamically colored based on the percentual value with colors like red hinting at a “bad” result, yellow for “mediocre” and green for “good”. There are default color schemes (always grey, green or red or dynamically calculated red/yellow/gree-shade as described above), but you may also assign any static color or your own JavaScript function mapping the value into a color.</p>

<h2 id="examples">Examples</h2>

<p>See the examples pages to get an impression of the looks and for different demo scenarios. </p>

<ul>
<li><code>examples.html</code>: Examples for direct usage of the plug-in</li>
<li><code>examplesAppl.html</code>: Examples for indirect use with <code>progresspiesvlAppl.js</code></li>
<li><code>examplesContentPlugins.html</code>: Examples for usage of the bundled content plug-ins (control icons, check complete and value display)</li>
<li><code>examplesAnimation.html</code>: Examples for configuring animated value transitions</li>
</ul>

<p>You&#8217;ll also find an online live view of these examples on the <a href="http://www.isg-software.de/progresspie/indexe.html">project&#8217;s home page</a>.</p>

<h2 id="javascripts">JavaScripts</h2>

<p>This package contains 5 JavaScript files (sources in folder <code>js</code> and minified production versions in <code>js/min</code>):</p>

<ul>
<li><code>jquery-progresspiesvg.js</code>: The jQuery plug-in itself. It may be used stand-alone.</li>
<li><code>jquery-progresspiesvg-controlIcons.js</code>: A content plug-in as an addition to the jQuery plug-in above. Loading this file on top of jquery-progresspiesvg.js enables you to draw control icons (play, stop, pause) inside ring graphs using the <code>svgContentPlugin</code> option of the progresspiesvg plug-in.</li>
<li><code>jquery-progresspiesvg-checkComplete.js</code>: A content plug-in which may add a check mark to a pie or ring graph for value 100%.</li>
<li><code>jquery-progresspiesvg-valueDisplay.js</code>: A content plug-in for displaying values (percent numbers or other values converted to percent, e.g. seconds of a minute) in the center of a ring graph.</li>
<li><code>progresspiesvgAppl.js</code>: This is meant to simplify the use for those who do not want to write JavaScript code to apply and configure the plug-in. This script file may be included into your HTML (in addition to jQuery and the plug-in above). If you do so, you may insert progresspie charts simply by writing HTML, inserting the percent values and assigning some predefined CSS classes or <code>data</code>-Attributes.</li>
</ul>

<h2 id="changesinv2.0.0backwardscompatibility">Changes in V2.0.0, backwards compatibility</h2>

<p>Version 2 mostly adds new features like especially:
* Rendering rewritten to produce more compact SVG markup. (Rings and pies are now only a single elliptic stroke with instead of a filled area.) This was also precondition for the next feature:
* optional SMIL animation/transition (see <code>examplesAnimation.html</code>)
* More features for the <code>inner</code> option (second value/pie/ring):
 * background circle now also supported for inner rings/pies
 * “Double pies” extended to “multiple pies”: The <code>inner</code> option may itself contain an <code>inner</code> option (recursive)
* CSS support:
 * background circles and foreground pie or ring segments now always get a <code>class</code> attribute so you can define external CSS rules to modify or enhance their formatting.
 * new predefined <code>CSS</code> mode disables some inline formatting like colors in the generated SVG code or the inline style <code>vertical-align</code> in the <code>svg</code> node, in which case the formatting should be defined externally via CSS rules.
* <code>overlap</code> option
* Extended content plug-in API able to suppress the output of the actual pie or ring chart, especially if the content plug-in would totally cover/occlude it. This generates more compact SVG (without needlessly rendering effectively invisible graphics) and also draws “cleaner” edges around full size filled backgrounds of content plug-ins.</p>

<p>But some changes have been made which could <em>affect backwards compatibility</em> in a few cases. This is the main reason for the major version increase (see [semantic versioning][https://docs.npmjs.com/getting-started/semantic-versioning]): When updating to V2.0.0, you should make sure the following changes don&#8217;t affect your current uses, otherwise you might have to (slightly) change them.</p>

<ul>
<li>The <code>separator</code> option is now ignored when inserting an SVG into a hitherto empty HTML element (e.g. <code>&lt;span id=&quot;pie&quot; data-percent=&quot;50&quot;&gt;&lt;/span&gt;</code>). In Versions 1.x.x, the <code>separator</code> (wich actually only serves to separate the prepended or appended SVG from the content of the node) was still appended, even if there was nothing to separate. This could have had some unwanted effects, e.g. if the target element was CSS-formatted to have a background color and the SVG should be centered inside, but was not due to the space appended to it. On the other hand: If you&#8217;ve been relying on this separator being inserted even into empty documents, you&#8217;ll now have to put it into the document by yourself. Example: If you had some markup like <code>&lt;span id=&quot;pie&quot;…&gt;&lt;/span&gt;&lt;span id=&quot;X&quot;&gt;…&lt;/span&gt;</code> and relied on a space being inserted after the SVG into the <code>#pie</code> element so that the pie and the content of <code>#X</code> were separated, you&#8217;d best now insert a space directly between the two span elements.</li>
<li>The default valueAdapter function now uses <code>parseFloat</code> instead of <code>parseInt</code> for parsing string numbers, meaning that it now supports decimal digits if the dot (<code>.</code>) is used as decimal separator.</li>
</ul>

<p>Changes like having a separator only separate the newly inserted and old content and not (any more) adding a ‘separator’ that&#8217;s actually not separating anything, these are more kind of a fix than a new feature. They IMHO make sense, but sadly they affect backwards compatibility. Other than that, I&#8217;ve strived to retain backwards compatibility as far as possible, and most users won&#8217;t probably have to change anything.</p>

<h2 id="usage">Usage</h2>

<h3 id="directusageoftheplug-inwithoutprogresspiesvgappl.js">Direct usage of the plug-in (without <code>progresspiesvgAppl.js</code>)</h3>

<h4 id="basics">Basics</h4>

<ul>
<li><p>Include jQuery (tested with jQuery 1.11, but should work with jQuery 2, too) and the script file <code>jquery-progresspiesvg.js</code> into the head of your HTML file.</p></li>
<li>Insert the percent values into your HTML body that are to be visualized. This may be done in two ways:

<ul>
<li>Should the number be visible and a pie in text height should be inserted before or behind the acutal number? This is the default. In this case, for each progresspie to insert, write the number (and only the up to three digits) into an HTML element like <code>span</code> and make sure this element may be selected via jQuery (e.g. by adding a classname like &#8220;percent&#8221; or &#8220;progresspie&#8221;). Example: <code>&lt;span class=&quot;percent&quot;&gt;42&lt;/span&gt;&amp;nbsp;%</code>.</li>
<li>Should the number / digits be invisible and only a pie is to be inserted? In this case create an empty HTML element where the pie chart is to be inserted and write the number into an attribute of this element (usually prefixed with <code>data-</code>), e.g.: <code>&lt;span class=&quot;pie&quot; data-percent=&quot;42&quot;&gt;&lt;/span&gt;</code>.</li>
</ul></li>
<li><p>Write and include some script code that gets executed after rendering the HTML (generating the DOM). This code is to select the (<code>span</code>-) elements you created in the second step with a jQuery query and to apply the plug-in to the selection/query result.
Example corresponding to both data elements above:</p>

<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;
    $(function() {
        $(&quot;.percent&quot;).progressPie(); //default mode
        $(&quot;.pie[data-percent]&quot;).progressPie({ //specifying options object
            valueData:&quot;percent&quot;,
            color:&quot;navy&quot;,
            size:30
        });
    });
&lt;/script&gt;
</code></pre></li>
<li><p>For each selected element, the script will try to read the number (from the element&#8217;s content or from a data attribute, if the option <code>valueData</code> is given and the element provides a data attribute, prefixed with <code>data-</code>, of that name or the data is set by calling jQuery&#8217;s <code>data()</code> method) and render the piechart SVG, which will be inserted into the selected element. </p></li>
<li><p>By default the SVG image gets prepended to the content, optionally it may also be appended. Also, a <code>separator</code> string may be inserted between the pie and the original content (by default this is a non-breaking space: <code>&amp;nbsp;</code>). If the target element is empty (like in the second example with the data attribute), the SVG is simply inserted into that element without the separator.</p></li>
<li><p>In case the values aren&#8217;t static but should be updatable, the initialization should be done with the <code>setupProgressPie()</code> method and the parameterless <code>progressPie()</code> method can be used multiple times to (re)draw die graph:</p>

<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;
    $(function() {
        $(&quot;.pie[data-percent]&quot;).setupProgressPie({ //specifying options
            valueData:&quot;percent&quot;,
            color:&quot;navy&quot;,
            size:30
        }).progressPie(); //draw the pie (1st time) using the above setup.
    });
    function demoUpdate(p) {
        $(&quot;.pie[data-percent]&quot;).data(&quot;percent&quot;, p).progressPie();
        //update the percent data and initiate redraw. (The progressPie()
        //method will read the &quot;percent&quot; data as specified in the setup.)
    }
&lt;/script&gt;
</code></pre></li>
</ul>

<h4 id="options">Options</h4>

<p>If you simply call <code>progressPie()</code>, the plug-in will be used with default options. This includes that the percent number is expected to be the (only) content of the selected element, the pie will be prependet to this content (separated with an <code>&amp;nbsp;</code>), it will be rendered in line-height and in a shade of grey (<code>#888</code>). It will only be inserted, if the element does not yet contain any SVG content: repetetive calling of the function will therefore neither insert the SVG multiple times nor will it update the graphic.</p>

<p>To modify the looks or behaviour, the function takes exactly one argument, which has to be a JavaScript object which defines options via its properties. The following option properties are defined:</p>

<ul>
<li><code>mode</code>: constant of enum type <code>$.fn.progressPie.Mode</code>. Default is <code>$.fn.progressPie.Mode.GREY</code>. Possible values are:

<ul>
<li><code>$.fn.progressPie.Mode.GREY</code>: Default Mode, pie is drawn in a shade of grey.</li>
<li><code>$.fn.progressPie.Mode.RED</code>: The pie is drawn in red color regardless of the percentual value.</li>
<li><code>$.fn.progressPie.Mode.GREEN</code>: The pie is drawn in green color regardless of the percentual value.</li>
<li><code>$.fn.progressPie.Mode.COLOR</code>: The color of the pie is depending on the percentual value (see above). The color is the same green color as in mode GREEN for a value of 100 percent, the same red color as in mode RED for a value of 0%, a yellowish mix of both for 50% and a gradient in between green and yellow for values greater than 50% resp. between red and yellow for values less than 50%.</li>
<li><code>$.fn.progressPie.Mode.CSS</code>: The colors (<code>stroke</code> of foreground and background and <code>fill</code> of background) as well as the <code>vertical-align</code> style of the root <code>svg</code> element are left unspecified. If this mode is chosen, you have to define the colors and vertical alignment via CSS rules (see examples)!</li>
</ul></li>
<li><code>strokeWidth</code>: number. Default is <code>2</code>. Determines the stroke with of the background circle.</li>
<li><code>strokeColor</code>: string, color code. Default is <code>undefined</code>. If undefined, the background circle is drawn in the same color as the rest of the pie. If set to a color code like <code>#ddd</code> or <code>silver</code>, this defines the color of the background circle.</li>
<li><code>overlap</code>: boolean, defaults to <code>true</code>. If <code>true</code>, the foreground (pie/ring segment) is drawn full size, i.e. with the same radius as the background circle, so the foreground overlaps the background. This is usually only visible, if the <code>strokeColor</code> (color of the background circle) is set and differs from the foreground&#8217;s color. Set this to <code>false</code> in order to fit the foreground (pie/ring) inside the blank space of the background circle.</li>
<li><code>ringWidth</code>: number. Default is <code>undefined</code>. If undefined, a portion of the pie will be filled, cut out just to the center of the circle (like a partial sweep of a radar). If ringWidth is a number, only the outer rim of this piece of the pie is drawn, leaving an empty circle in the middle with diameter <code>size-2*ringWidth</code>. If no <code>strokeColor</code> is defined (and <code>overlap</code> is true) <code>ringWidth</code> must be greater than <code>strokeWidth</code> in order for the (partial) ring to be visible. (See examples)</li>
<li><code>ringEndsRounded</code>: boolean. Default is <code>false</code>. Only applicable if <code>ringWidth</code> is defined, ignored in pie mode. If a ring is drawn, both ends of the ring are normally cut rectangularly. Enabling this option draws a semicircle cap on each end. This might look prettier especially for very large graphics with usually <code>strokeWidth === 0</code>. Note however that, the higher the <code>ringWidth</code> value, the longer the ring seems, for the semicircles are <em>added</em> to the ring. Very high values like 99% will then look like a full 100% (for the semi circle ends overlap).</li>
<li><code>prepend</code>: boolean. Default is <code>true</code>. If true, the pie will be inserted at the beginning of the element&#8217;s content, followed by the separator string. If <code>false</code>, the separator string followed by the pie will be appended to the element&#8217;s content. If the target element is completely empty, the pie will become the sole content, this option (as well as the <code>separator</code> option, see below, will be ignored).</li>
<li><code>separator</code>: string. Default is <code>&quot;&amp;nbsp;&quot;</code>. Will separate the inserted pie from the rest of the content (usually the number), see <code>prepend</code>. Ignored for empty elements.</li>
<li><code>verticalAlign</code>: string. Default is <code>&quot;bottom&quot;</code>. Defines the CSS-property <code>vertical-align</code> of the inserted SVG element and thus the vertical alignment. By default, the image is aligned with the bottom of a line. In certain circumstances (like setting a <code>line-height</code> style greater than <code>1em</code>) you might want to vertically center the image by setting this option to <code>&quot;middle&quot;</code>. (This option is ignored in CSS mode, see above, since in that mode no local <code>vertical-align</code> style will be defined at all, but it&#8217;s left to you to define a global CSS rule for the alignment!)</li>
<li><code>update</code>: boolean. Default is <code>false</code>. If false, the function will do nothing if the target element already contains an <code>svg</code> element. Set to <code>true</code> if repeated calls are meant to update the graphic. If <code>true</code>, the function will remove an existing <code>svg</code> before inserting a new one. Typically only needed in combination with <code>valueData</code> or <code>valueAttr</code>, see also: Dynamically updating pies</li>
<li><code>size</code>: number. Default is <code>undefined</code>. If undefined, the plug-in will try to draw the pie in the actual height of the parent element. Beware: If the element is empty, the browser may have calculated a height of 0! In this case, a default size will be used. Defining this option disables auto-sizing: the provided number will be used as height and width of the <code>svg</code>. It has to be a number (in pixels), not a string with a unit! This is typically used on empty elements in combination with <code>valueData</code>, <code>valueAttr</code> or <code>valueSelector</code>.</li>
<li><code>sizeFactor</code>: number. Default is 1. The size (either given by <code>size</code> option or auto-calculated, if no <code>size</code> is explicitly specified) is multiplied by this factor to get the “final” diameter before drawing the chart.</li>
<li><code>scale</code>: number. Default is 1. The already rendered SVG is finally scaled by this factor. In difference to <code>sizeFactor</code> this does not simply change the diameter/radius of the chart, but scales all other aspects, such as <code>strokeWidth</code>, <code>ringWidth</code> etc., too.</li>
<li><code>valueAttr</code>: string. Default is <code>undefined</code>. Name of a value attribute: If defined, the function will look for an attribute of this name inside the opening tag of the found element, and if found, it will parse this attribute&#8217;s value instead of the element&#8217;s content as the percent value. (If defined but not of type &#8220;string&#8221;, the function will throw an exception.) For accessing <code>data-*</code> attributes, the next option <code>valueData</code> is usually preferred, use <code>valueAttr</code> only if you want to read other attributes (not beginning with <code>data-</code>) or if you really want to react to updates to the attribute in the DOM tree.</li>
<li><code>valueData</code>: string. Default is <code>undefined</code>. Mutually exclusive with <code>valueAttr</code> and <code>valueSelector</code>! Name of a jQuery data object. When parsing, jQuery will create data objects for each <code>data-*</code> attribute, e.g. for an attribute <code>data-percent=&quot;50&quot;</code> in the HTML, the jQuery function <code>data(&quot;percent&quot;)</code> will return the <em>number</em> 50 (not a string). In this example, you may specify the option <code>valueData: &quot;percent&quot;</code> to access the data from the <code>data-percent</code> attribute. This is <em>nearly</em> equivalent to <code>valueAttr: &quot;data-percent&quot;</code>, but differs in two important respects: Firstly, numbers are automatically recognized and parsed, so the <code>valueAdapter</code> does not have to parse the string itself, secondly (and most important), value updates set by calling the jQuery function <code>data(id, newValue)</code> (e.g. <code>$(selector).data(&quot;percent&quot;, oldvalue++)</code>) will be recognized when updating the pies. Be aware that jQuery does not update data-attributes upon calling the <code>data</code>-setter-function. Attributes and stored data objects only match initially, but updates to the data objects are not propagated to the string attributes in the DOM tree. So if you were using option <code>valueAttr: &quot;data-percent&quot;</code> instead of <code>valueData</code> and wanted to dynamically update the pie, you&#8217;d have to explicitly update the data attribute via jQuery function <code>attr(&quot;data-percent&quot;, newValueAsString)</code>, whereas use of <code>valueData</code> enables you to simply update the value via <code>data(&quot;percent&quot;, newValueAsNumber)</code>, which is simpler and more efficient. (If this option is defined but not of type &#8220;string&#8221;, the function will throw an exception.)</li>
<li><code>valueSelector</code>: jQuery-Selector (string). Default is <code>undefined</code>. Mutually exclusive with <code>valueAttr</code> and <code>valueData</code>! If defined, the function will apply a jQuery search within the selected element to find a sub-element whose text content is to be used as a value. Usually, the whole text content of the node previously selected (to which the progresspie plug-in is applied) is interpreted as the value. If you want to have more content, maybe for CSS styling reasons, and the actual value is in a sub-element, but the pie should not be inserted into that sub-element but into the previously selected main element, then this option is for you. The examples page demonstrates an application of this option.</li>
<li><code>valueAdapter</code>: function. Default: see below. The valueAdapter function is executed when interpreting the value, i.e. either the element&#8217;s content (string), the value of the attribute denoted by the <code>valueAttr</code> option (also a string) or the data object denoted by the <code>valueData</code> option. It has to map the value (string or number) to a number within the range [0..100], which is then used to calculate the pie graphic. So if you have raw data that&#8217;s not a percent value (for example an hour value out of [0..12]), you may write an own valueAdapter reading this value and returning an int in [0..100]. (See examples page.)

<ul>
<li>If you use the <code>valueData</code> option, the type of the argument is the type of the object stored in the data model. This is usually a string or a number, but your own script code controls the type of objects stored there.</li>
<li>If you don&#8217;t use the <code>valueData</code> option, the type of the argument is always <code>string</code>.</li>
<li>The default valueAdapter <code>$.fn.progressPie.defaults.valueAdapter</code> (which is used whenever this option <code>valueAdapter</code>is undefined) applies <code>parseInt</code> to any <code>string</code> argument, returns any <code>number</code> argument unchanged and returns <code>0</code> for an argument of any other type.</li>
</ul></li>
<li><code>color</code>: string or function. Default is <code>undefined</code>. If undefined, the color of the pie depends on the <code>mode</code> option, see above. A valid string value of this option would be a color name like <code>navy</code> or color code like <code>#888</code>, <code>#FF00BC</code>, <code>rgb(10,20,255)</code>. If the value is a function, this function has to read one parameter of type number (0..100) and return a color code (string). If the option is neiter <code>undefined</code> nor a string nor a function, the plug-in will throw an exception.</li>
<li><code>colorAttr</code>: string. Default is <code>undefined</code>. Only evaluated if <code>color</code> is undefined. Name of a color attribute: If defined, the function will look for an attribute of this name inside the opening tag of the found element, and if found, will try to use the attribute&#8217;s content (string) to set the pie color. The attribute must contain a color name or code (see <code>color</code>).</li>
<li><code>colorFunctionAttr</code>: string. Default is <code>undefined</code>. Only evaluated if no color has already been set with <code>color</code> or <code>colorAttr</code>. Name of an attribute containing JavaScript code (as string literal) for calculating a color.</li>
<li><code>animate</code>: boolean or object. Default is <code>undefined</code>. May be set to <code>true</code> for default animation options (defined in <code>jQuery.fn.progressPie.defaultAnimationAttributes</code>) or to an object containing valid SMIL options (key-value-pairs like <code>dur</code> for the animation duration) in order to set up a customized animation. Animation is applied for static pies when rendering the page (the animation then starts at 0% and gradually fills the chart up to the assigned percent value) and is also applied for each redraw of the chart (animating the transition from the previous to the newly set value). See separate animation examples page and jsDoc for the <code>defaultAnimationAttributes</code> object.

<ul>
<li>If you use the <code>inner</code> option (see below) to add a second or even more values, these inner options inherit the <code>animate</code> option in case they don&#8217;t define it themselves. To disable an inherited animation for an inner value, <code>inner.animate</code> may simply be set to <code>false</code>.</li>
</ul></li>
<li><code>animateColor</code>: boolean. Default is <code>undefined</code>. Effectless if the <code>animate</code> option is not set (or <code>false</code>) or if the color of the chart is constant. So let&#8217;s assume you use a color function, so that a value change also may cause a change of the diagram&#8217;s color:

<ul>
<li>If this option is set to <code>false</code>, the chart will immediately be drawn in the final color, the <code>animate</code> option will only add a value transition. Especially when incrementing or decrementing the value and redrawing/updating the pie, the color will change abruptly even before the value change transition starts.</li>
<li>If this option is set to <code>true</code>, in addition to the value transition also a color transition is added. Note that the easiest, ‘direct’ color transition between start and target color is used, i.e. the intermediate colors do not necessarily comply with your color function&#8217;s results for the intermediate percent values!</li>
<li>If this option is left <code>undefined</code>, a <em>default color transition mode</em> is used, which means: Upon the <em>first</em> drawing of a pie (loading the page), the pie will immediately be drawn in the final color (as with <code>false</code> value), only the value will be filled animatedly. Each <em>redraw/update</em> on the other hand will use color transition (as with <code>true</code> value).</li>
<li><em>The latter (default mode) is the recommended setting, only define the <code>animateColor</code> option if you either want to completely disable color transitions for redraws (<code>false</code>) or if you explicitly want to enable color animation even for the first drawing upon page load (<code>true</code>).</em></li>
</ul></li>
<li><code>inner</code>: Object. Default is <code>undefined</code>. This object may contain a subset of the option properties described above {<code>mode</code>, <code>color</code>, <code>colorAttr</code>, <code>colorFunctionAttr</code>, <code>valueData</code>, <code>valueAttr</code>, <code>valueSelector</code>, <code>valueAdapter</code>, <code>size</code>, <code>strokeWidth</code>, <code>strokeColor</code>, <code>strokeDashes</code>, <code>overlap</code>, <code>ringWidth</code>, <code>ringEndsRounded</code>, <code>animateColor</code>, <code>animate</code>, <code>inner</code> (recursive)}. If <code>inner</code> is not undefined, then <em>two</em> piecharts will be drawn: An outer, larger chart with circle around it, described with all the other options, and a second, smaller, inner pie on top of the outer. The inner circle&#8217;s value might be taken from a second attribute (denoted by <code>inner.valueAttr</code>) or might be calculated from the same value string as the outer value, just by a different <code>inner.valueAdapter</code> mapping. At least one of these two options should be defined. Also, the inner pie should have a different color than the outer one, defined by <code>inner.mode</code> or <code>inner.color</code>. If <code>inner.size</code> is specified, the outer <code>size</code> option should also be set manually and should be larger than <code>innser.size</code>. If <code>inner.size</code> is left undefined, the inner pie is automatically slightly smaller than the outer one (approx. two thirds of the outer). If the <code>inner</code> option contains yet another <code>inner</code> option, than a third pie with those options is added, and so an.</li>
<li><code>rotation</code>: string, boolean or object. Default is <code>undefined</code>. If this option is ‘truthy’ (i.e. not <code>undefined</code>, not <code>false</code>, not <code>0</code> etc.), the (outer) pie or ring fragment will be animated by rotating around its center. The default speed is one rotation per second, the default direction is clockwise. (Both are applied, if you set <code>rotation: true</code>.) If the option is a string, this will be inserted into the <code>dur</code>-Attribute of the SVG animation, i.e. it will define the rotation speed by setting the duration for one full (clockwise) rotation. Legal values are numbers with units like <code>&quot;2s&quot;</code> for two seconds or <code>&quot;500ms&quot;</code> for 500 milliseconds, i.e. half a second. rotation may also be an object with _two (sub-)properties_: <code>duration</code> defining the duration of one turn (just like the simple string value for <code>rotation</code>, <code>clockwise</code> is a boolean defining the rotation direction. Set this to <code>false</code> for an anti-clockwise rotation.
It&#8217;s not recommended to define a <code>rotation</code> for pies or rings acually measuring a progress, but for usage with constant values to draw a “busy-indicator” like a rotating ring with a small gap. The constant value (like 90% for a ring with a 10% gap) may be specified by setting a <code>valueAdapter</code> function returning this constant. See <code>examples.html</code>!</li>
<li>CSS class name options. Individual components of the rendered SVG graphic are equipped with CSS class attributes. This enables you to apply external CSS styling rules. The following options may be added to the progressPie function call in order to override the default CSS class names:

<ul>
<li><code>cssClassBackgroundCircle</code>: string. Defaults to <code>&quot;progresspie-background&quot;</code>. This value get set as CSS class (via an attribute <code>class=&quot;progresspie-background&quot;</code>) to the closed circle shape always drawn as background behind the actual pie or ring.</li>
<li><code>cssClassForegroundPie</code>: string. Defaults to <code>&quot;progresspie-foreground&quot;</code>. Just like the option above, only this class is assigned to the actual pie or ring segment drawn on top of the background circle.</li>
<li><code>cssClassOuter</code>: string. Defaults to <code>&quot;progresspie-outer&quot;</code>. In case you specify the <code>inner</code> option in order to display a second (or even more) inner pies or rings, this class is assigned to both background and foreground of the outer graph. E.g. the outer background circle is equipped by default with an attribute <code>class=&quot;progresspie-background progresspie-outer&quot;</code>.</li>
<li><code>cssClassInner</code>: string. Defaults to <code>&quot;progresspie-inner&quot;</code>. In case you specify the <code>inner</code> option, this CSS class is assigned to the second (i.e. the (first) inner) graph just like the <code>cssClassOuter</code> option is to the outer graph. In case you use nested <code>inner</code> options, starting with the third chart (the “inner inner chart”) a number (starting with 2) is appended to this class name. E.g. the foreground of the third (“inner inner”) chart will bear the attribute <code>class=&quot;progresspie-foreground progresspie-inner2&quot;</code>.</li>
<li>Please note that these four options must be “root options” of the plug-in call. I.e. it&#8217;s not supported to add these options to an <code>inner</code> option object.</li>
</ul></li>
<li><code>optionsByPercent</code>: function. Default is <code>undefined</code>. You may specify a function which takes the percent value (0..100, if a value adapter is used, this is the value returned by the adapter) and either returns <code>null</code> or an object with progresspie options from this very list, depending on the percent value. If, for some value, the function returns <code>null</code>, it has no effect. If, for some value(s) it returns an object, the options returned will override the global options passed directly to the jQuery plug-in. So, for example, you may specify a function returning null for any value &gt; 0, but returning some other options for rendering a rotating ring for a value of still 0%. (Actually, this is a more universal version of setting a <code>color</code> function, since it may not only override a global color based on the depicted value, but may also change other properties like size, stroke with, rotation etc.)</li>
<li><code>contentPlugin</code>: string of function. Default is <code>undefined</code>. Specify a content plug-in function to add content on top of a pie chart or inside of a ring chart. See section “SVG Content plug-ins”.</li>
<li><code>contentPluginOptions</code>: object. If the <code>contentPlugin</code> option is set, this object may provide plug-in-specific options for configuring the content plug-in&#8217;s output. See section “SVG Content plug-ins”.</li>
</ul>

<h4 id="dynamicallyupdatingpies">Dynamically updating pies</h4>

<p>The default usage is to have some static percent values (or even other kinds of values which can be transformed to a percent value using a value adapter function, see options / examples) and to insert pie graphs visualizing those values.</p>

<p>But of course your values might get updated (via JavaScript). If that happens, the derived pie charts are not automatically updated too, but your script code updating the values has to trigger a pie update as well.</p>

<p>In fact, the existing SVG code does not really get updated (meaning: modified), but completely replaced by a newly generated SVG image.</p>

<p>In order to redraw a pie, you <em>might</em> simply use usual <code>$(target).progressPie({options...})</code> call, repeating the options all over. But <em>if</em> you do that, pay attention to the <code>update</code> option: If you leave it set to false, existing graphics won&#8217;t be replaced, but only missing graphics will be drawn:</p>

<ul>
<li>In default mode (i.e. your value is content of an HTML element and the SVG gets prepended (or appended) to this content) a dynamic value update is usually achieved by:

<ul>
<li>overwriting the content with a new value, effectively removing the previously rendered pie, and</li>
<li>re-calling the plug-in to render any missing pies. Since the content replacement has already removed the previous pie from the document, the <code>update</code> option may stay set to false (default value).</li>
</ul></li>
<li>In <code>valueData</code> or <code>valueAttr</code> mode (the number is not visible but present as an attribute to the element whose content usually—but not necessarily—consists only of the pie), an update is best achieved by:

<ul>
<li>overwriting the value data (using jQuery&#8217;s <code>data()</code> function) or attribute and</li>
<li>re-calling the plug-in with option <code>update: true</code>.</li>
</ul></li>
</ul>

<p>But usually, the options should stay constant and only the displayed value changes. In this case, it&#8217;s best not to repeat the options with each update call. </p>

<p>Therefore, the <em>recommended</em> way is to setup the options once before first drawing the pie(s) (using the <code>setupProgressPie()</code> function) and then to redraw it (them) by only calling the parameterless <code>progressPie()</code> function (see section Basics above). If you do that, you also don&#8217;t have to bother thinking about the <code>update</code> option: When you use <code>setupProgressPie()</code> and don&#8217;t specify the <code>update</code> option, it automatically defaults to true, meaning each parameterless <code>progressPie()</code> call will update existing pies.</p>

<p>Have a look at the examples page to see updates in action.</p>

<p>Since version 2.0.0, updates may also use transitions, such that the update triggers an animation smoothly increasing (or decreasing) the pie or ring chart&#8217;s state starting from the old value (before the update) and ending with the current value. (SMIL animations are not supported by all browsers, especially neither Microsoft Internet Explorer nor Edge support them. The charts will sill be updated on those browsers, only the animation will be missing.)
To use animation, simply add the <code>animate</code> option, maybe combined with the <code>animateColor</code> option, see above, to the setup.</p>

<p>See the separate <code>examplesAnimation.html</code> page for demonstration.</p>

<h4 id="overwritingdefaultoptions">Overwriting default options</h4>

<ul>
<li>You may insert a JavaScript code executed immediately when loading the document (but only after loading the jQuery plug-in) that modifies the <code>$.fn.progressPie.defaults</code> object by either overwriting a property with a new default value other than that described above or by introducing a new property with a default value for an option that is normally undefined by default.</li>
<li>The default color for progresspies (<code>#888</code>) is defined in the property <code>color</code> of the default Mode enum constant: <code>$.fn.progressPie.Mode.GREY.color</code>. This is a string property and may be overwritten with any valid color code in order to set a different default color for the default mode (<code>GREY</code>).</li>
<li>Similarly, the default colors for modes <code>COLOR</code>, <code>GREEN</code> and <code>RED</code> are stored in properties of the Mode enum values:

<ul>
<li><code>$.fn.progressPie.Mode.RED.value</code> is a number between 0 and 255 (inclusive), i.e. a byte, defaulting to 200.</li>
<li><code>$.fn.progressPie.Mode.GREEN.value</code> is also a byte defaulting to 200.</li>
<li>The color in mode <code>RED</code> is simply <code>rgb($.fn.progressPie.Mode.RED.value, 0, 0)</code>.</li>
<li>The color in mode <code>GREEN</code> is thus <code>rgb(0, $.fn.progressPie.Mode.GREEN.value, 0)</code>.</li>
<li>The color in mode <code>COLOR</code> is calculated by <code>$.fn.progressPie.colorByPercent(number)</code> as an RGB code also based on these constants.</li>
<li>Thus, if you want to use these modes but want to adjust the brightness of the calculated colors, you may adjust these properties.</li>
</ul></li>
</ul>

<h4 id="writingyourowncolorfunction">Writing your own color function</h4>

<p>As described above, by simply setting the option <code>{mode: $.fn.progressPie.Mode.COLOR}</code>, the color of the pie get dynamically calculated based on the percent value, and the colors used for that are in some degree customizable via overwriting <code>$.fn.progressPie.Mode.GREEN.value</code> or <code>…RED.value</code>. </p>

<p>But if you want more flexibility in dynamically setting a color, you may provide your own JavaScript function which receives the percent value as parameter (number) and has to return a string describing the color (like <code>#3bf</code> or <code>rgb(100,255,100)</code>).</p>

<p>You could simply <em>overwrite</em> the function <code>$.fn.progressPie.colorByPercent</code>. This way your function would always be applied for any pie rendered in <code>COLOR</code> mode. </p>

<p>But the more flexible way is to write one or more own color functions and apply them individually to (classes of) pies instead of using the default <code>COLOR</code> mode, which is then still available.</p>

<p>Simply write your function and then set a reference to it in the options passed to the options, like in:</p>

<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;
function blueGt25(percent) {
  var blue = percent &lt; 25 ? 0 : (percent-25)*3; //range from 0 to 3*75 = 225 ( = max brightness for value of 100%)
  return &quot;rgb(0,0,&quot; + blue + &quot;)&quot;;
}

$(function() {
  $(&quot;.test.myblue&quot;).progressPie({color:blueGt25});
});
&lt;/script&gt;
</code></pre>

<p>The example above defines a color function which sets the pie color to black for all values of 0% to 25% inclusive. For values greater than 25% the color is blue: an rgb code with red and green values of 0 and a blue component growing brighter with the percent value up to 225 (a little darker than the brightest blue (255)).</p>

<p>Of course, a color function may also be embedded inline in the options object, if it&#8217;s not needed elsewhere. The following example defines an inline function setting one (greenish) color for values starting at 50% and another color (reddish) for lower values:</p>

<pre><code>$(&quot;.test.myfunc&quot;).progressPie({color:function(percent) {
  return percent &gt;= 50 ? &quot;#3f3&quot; : &quot;#f33&quot;;
}});
</code></pre>

<p>Last but not least you may <strong>reuse the internal color function</strong> <code>$.fn.progressPie.colorByPercent</code> within your own color function instead of calculating a color code all by yourself: Let&#8217;s say, you want all values between 0% and 50% to be drawn in the same red and apply the default <code>COLOR</code> scheme only for values starting at 50% (green for 100%, yellow for 75%, red for 50%). This could be done the following way:</p>

<pre><code>function colorGt50(percent) {
  var p = percent &lt;= 50 ? 0 : 2 * (percent - 50);
  return $.fn.progressPie.colorByPercent(p);
}
</code></pre>

<h4 id="valueadaptersanddoublemultiplepies">valueAdapters and double/multiple pies</h4>

<p>If the source value to be visualized as filled circle (pie) is not a percent value (0..100), you may write your own adapter function for mapping the actual values (any string) to a percent number (any number in [0..100], may be int or float). This mapping might be of arithmetic nature (e.g. converting a value of 0 to 60 minutes into a percent number) or of syntactic nature (e.g. extracting a percent number out of a string also containing other characters)—or both. Use the <code>valueAdapter</code> option (see above) to specify your adapter function. (The default value adapter is a function returning any number input unchanged, parsing any string input via <code>parseFloat</code>, and otherwise returning 0.)</p>

<p>If you want to display <em>two</em> values in one graphic (e.g. hours and minutes), that&#8217;s also possible—not as simple to read/understand at first glance, though. Use the <code>inner</code> option (see above) to specify that and how a second, inner pie should be generated. By adding yet another <code>inner</code> options into the first <code>inner</code> option, you may even add a third value and so on.</p>

<p>The examples page <code>examples.html</code> contains demonstrations for both options.</p>

<p>Note: These features are only available with direct use of <code>jquery-progresspiessvg.js</code> and not via <code>progresspiesvgAppl.js</code>.</p>

<h3 id="simplifiedusageviaprogresspiesvgappl.js">Simplified usage via <code>progresspiesvgAppl.js</code></h3>

<p>If you prefer not to write your own JavaScript-/jQuery-Code in order to apply the progresspie plug-in to selected elements of your choice, you may use this additional JavaScript file. It is a default application of the plug-ins to elements which must meet some conventions.</p>

<p>If you include this script into an HTML document, each HTML element <em>of class</em> <code>progresspie</code> is fitted with a pie chart. This requires the element (which is usually an inline element like a <code>span</code>) to contain a number from 0 to 100 (inclusive) as its only content or alternatively in an attribute named <code>data-percent</code>. </p>

<p>By default the pie is grey. By adding an additional <em>class</em> <code>color</code>, <code>red</code> or <code>green</code> you get a dynamically colored resp. statically red or green pie. (These classes must not be combined and activate the corresponding plug-in mode <code>COLOR</code>, <code>RED</code> or <code>GREEN</code> respectively.)<br/>
Adding the class <code>vcenter</code> activates vertical centering, otherwise the graphic is aligned with the bottom of the element.</p>

<p>For user-defined color you may either add an attribute <code>data-piecolor</code> defining a static color code or an attribute <code>data-piecolor-function</code> providung a string which evaluates to a function mapping a number (range 0..100) to a color code.</p>

<ul>
<li>See JsDoc documentation of the script file (Namespace <code>progressPies</code>) for a more detailed description.</li>
<li>See <code>examplesAppl.html</code></li>
</ul>

<h2 id="svgcontentplug-ins">SVG Content plug-ins</h2>

<p>The progresspieSVG jQuery plug-in provides a private plug-in mechanism itself, which may be used to plug additional drawing logic into the main plug-in, adding SVG content to the pie or ring chart.</p>

<p>To apply a content plugin, add the option <code>contentPlugin</code> to the argument object you pass to the jQuery plug-in. The value of this option is either a reference to a javascript function (conforming to the plug-in API as described below), or simply the name of a function as a string. In the latter case the function <em>must</em> be member of the namespace <code>jQuery.fn.progressPie.contentPlugin</code>. Only then it can be looked up by its name. This is the recommended namespace for any content plug-in.</p>

<p>A content plug-in may itself be configured by an object defining options. Any properties defined in an object passed to the jQuery progress pie plug-in via its option <code>contentPluginOptions</code> will be passed along to the content plug-in specified by <code>contentPlugin</code>.</p>

<h3 id="controlicons">Control Icons</h3>

<p><code>jquery-progresspiesvg-controlIcons.js</code> is a script file defining three such content plug-ins <code>play</code>, <code>stop</code> and <code>pause</code> for drawing media control icons (a right-pointing triange, square or two parallel vertical rectangles, resp.) inside a ring graph. </p>

<p>By default, the play-, pause or stop icon is drawn in the same color as the pie/ring chart itself. If combined with a ring chart (i.e. option <code>ringWidth</code> is set, see above), it is auto-sized to fit inside the ring, otherwise it&#8217;s drawn on top of the pie and auto-sized to fit into the outer circle stroke. These defaults may be overridden by the following options (defined as properties of an object assigned to the <code>contentPluginOptions</code> option):</p>

<ul>
<li><code>color</code>: string, color code. Defines the color for the control icon.</li>
<li><code>maxSize</code>: number. If defined, this defines a maximum constraint for the auto-sizing: For the play and stop icon, <code>maxSize</code> defines the maximum width and height. The play icon is always a bit larger in height and width than the others, due to the fact that the triangle icon fills much less areas and thus looks smaller.</li>
</ul>

<p>See the content plug-ins example page for demonstrations of the plug-in and its options.</p>

<h3 id="checkifcomplete">Check if complete</h3>

<p><code>jquery-progresspiesvg-checkComplete.js</code> is a script file defining a single content plug-in (<code>checkComplete</code>). This plug-in will draw a check mark onto a fully filled pie or into a fully closed ring (i.e. on a graph visualizing a 100% value). It won&#8217;t add any content for lower values.</p>

<p>See the content plug-ins example page for demonstrations of the plug-in and its options.</p>

<h3 id="erroricons">Error icons</h3>

<p>Imagine you set up a pie graph for visualizing the progress of a running job of your web application. You set it up once (per <code>setupProgressPie()</code>) to configure the looks of the pie itself and you might add the checkComplete-Plugin described above to draw a checkmark on green ground as soon as the job is completed successfully.</p>

<p>But maybe the job could also terminate with an error or a warning, and in these cases you would want neither the green check mark for success nor a frozen pie chart which looks like it depicts a still running job. Instead you might want to change the graph into an error or warning icon similar to the white check on green background, e.g. a white cross or exclamation mark on red or green background.</p>

<p>This error icons plug-in serves exactly this purpose. In difference from checkComplete, which gets setup at the beginning to show the icon as soon as the progress value reaches 100%, an error or warning icon has to be added retrospectively by an error event handler function or similar means.</p>

<p>If you have loaded this plug-in script file, your event handler may show a cross or exclamation mark inside a ring or on a fully filled pie, the exclamation mark may also be rendered onto a triangle hovering on top of the pie or ring graph (or inside the ring). The icon may be drawn on a colored background (e.g. red or yellow) covering the pie or ring chart completely (just like the check mark), or it may be rendered on top of a pie (without opaque background) or inside the ring, if you want the job&#8217;s progress at the time the error occurred to still be visible.</p>

<p>See content plug-in example page for demonstrations (and JSDoc for details on all options).</p>

<h3 id="valuedisplay">Value Display</h3>

<p><code>jquery-progresspiesvg-valueDisplay.js</code> is a script file defining content plug-ins for drawing a value inside a ring graph.</p>

<p>This script defines two content plug-ins: <code>percent</code> and <code>rawValue</code>. Both are designed to be combined with ring charts (i.e. usage of the progressPie plug-in with the <code>ringWidth</code> option set) and draw a number (value) and optionally a unit label into the ring. The <code>percent</code> plug-in always renders a percent value (0..100).</p>

<p>If the chart is defined with other than percent values and a <code>valueAdapter</code> function is used to convert the raw value to a percent value, then the <code>percent</code> plug-in will render the result of the valueAdapter function, while the <code>rawValue</code> plug-in will draw the unconverted, raw value. The <code>percent</code> plug-in always adds the label &#8220;%&#8221; to the value, while the <code>rawVale</code> plug-in takes a <code>unit</code> argument defining an <em>optional</em> label to append to the value.</p>

<p>The plug-ins accept the following options (defined via <code>contentPluginOptions</code>):</p>

<ul>
<li><code>unit</code>: String. Default is <code>undefined</code>. Only for <code>rawValue</code> plug-in, ignored by <code>percent</code> plugin: This defines the unit label to append to the raw value, e.g. &#8220;sec.&#8221;</li>
<li><code>singleLine</code>: boolean. Default is <code>undefined</code>. If truthy, the unit (&#8220;%&#8221; or value of <code>unit</code>) will be put <em>behind</em> the value into the same line, otherwise (default) <em>below</em> the value in a second line.</li>
<li><code>fontSizeFactor</code>: Number. Default is 1.0 (or 0.9 if <code>singleLine</code> is truthy). The font-size for the value is the inner radius of the ring multiplied by this factor.</li>
<li><code>unitFontSizeFactor</code>: Number. Default is 0.35. Defines the font-size for the unit label.</li>
<li><code>color</code>: String, color code: Overrides the default color for value and unit (which is the same color as that of the pie/ring graph itself).</li>
</ul>

<p>Instead of passing an individual options object to the progressPie plugin via its <code>contentPluginOptions</code> option, you may also globally alter the defaults by manipulating the object <code>$.fn.progressPie.contentPlugin.valueDisplayDefaults</code>.</p>

<p>See the content plug-ins example page for demonstrations of the plug-in and its options.</p>

<h3 id="writingyourowncontentplug-insapi">Writing your own content plug-ins (API)</h3>

<p>You may create you own content plug-in:</p>

<p>With the older version of this API (of ProgressPieSVG V1.x), a content plug-in is simply a single function for drawing the content. Sine V2.0.0, ProgressPieSVG supports an extended API where your plug-in is an object consisting of a <code>draw</code> method for drawing the content and (for now) one second optional method which can be used to indicate to ProgressPieSVG in advance that the actual chart does not have to be drawn at all, that <em>only</em> your content plug-in&#8217;s draw method should be executed.</p>

<p>The plug-in function resp. object <em>should</em> be in the namespace <code>jQuery.fn.progressPie.contentPlugin</code>. If it is, the user may simply state the its name as a string literal in the <code>contentPlugin</code> option. Otherwise the options needs to hold a JavaScript reference to the content plug-in (function or object).</p>

<p>Just like when <a href="https://learn.jquery.com/plugins/basic-plugin-creation/">writing jQuery plug-ins</a>, you may locally bind the <code>$</code> sybol to <code>jQuery</code> in an immediately invoked function expression like (old API):</p>

<pre><code>( function($) {
    $.fn.progressPie.contentPlugin.yourPlugin = function(args) {
        …
    }
} (jQuery));
</code></pre>

<p>A plug-in using the new API could look something like this:</p>

<pre><code>( function($) {
    $.fn.progressPie.contentPlugin.yourPlugin = {
        draw: function(args) {
            …
        },
        hidesChartIfFullSize: function(args) {
            …
        }
} (jQuery));
</code></pre>

<h4 id="thedrawmethod">The <code>draw</code> method</h4>

<p>The <code>draw</code> function of your object (new API) resp. your plug-in function (old API) has to take exactly one argument (let&#8217;s assume you call the formal parameter <code>args</code> like in the examples above). When the <code>draw</code> function gets called by ProgressPieSVG, this parameter will hold an object with at least the following methods and properties:</p>

<h5 id="methodsoftheparameterobject">Methods of the parameter object</h5>

<ul>
<li><code>newSvgElement</code>: function(name). Your plug-in may call this function to insert a new SVG node directly into the pie graph SVG (in addition to the SVG output already produced by the progressPie jQuery plug-in itself). The argument <code>name</code> defines the element/tag name for the new element. The function return a reference to the newly created node which you need to configure the node, like adding attributes or child elements.</li>
<li><code>newSvgSubelement</code>: function(parent, name). If you want to add child elements to an SVG element, use this function. The first argument takes a reference to parent element you want to add a child node to, the second argument takes the tag name like in <code>newSvgElement</code>.</li>
<li><code>getContentPlugin</code>: function. This function takes a valid <code>contentPlugin</code> option, i.e. either a function or object reference to another content plug-in, or a string whose name has to be the name of a content plug-in function or object in the namespace <code>jQuery.fn.progressPie.contentPlugin</code>. It then returns a reference to the function (resp. object), i.e. if the argument is a function reference or a reference to an object containing a method named <code>draw</code>, it gets returned unchanged, if the argument is a string, the plug-in in the namespace gets looked up and the reference is returned. Throws exception if the argument is neither string nor function nor object with <code>draw</code> method, or if the string is invalid, i.e. no function (or object with <code>draw</code> method) of that name was found in said namespace. Normally content plug-ins won&#8217;t need to call this function, except if they support adding secondary content plug-ins (see <code>checkComplete</code> plug-in).</li>
<li><code>isFullSize</code>: function(). Returns <code>false</code> if the content should typically be fitted into a ring diagram, that is in ring mode without a truthy <code>fullSize</code> option (in the <code>contentPluginOptions</code>). Returns <code>true</code> if the <code>contentPluginOptions</code> contain an option named <code>fullSize</code> wich is <code>true</code> (or at least truthy) <em>or</em> in pie mode, i.e. if progressPie&#8217;s <code>ringWith</code> option is undefined.</li>
<li><code>getBackgroundRadius</code>: function(ignoreMargin). This may be used to calculate a radius for a potentially filled background circle for your content based on some standard content plug-in options: If your plug-in is combined with a pie (i.e. the option <code>ringWidth</code> of the <code>progressPie</code> parameter object is not defined) or if it&#8217;s combined with a ring chart and the <code>contentPluginOptions</code> include a truthy <code>fullSize</code> property (in other words: if the <code>isFullSize()</code> method returns <code>true</code>), then this will return the <code>totalRadius</code> property (see below).<br/>
If your content plug-in gets combined with a ring graph without a <code>fullSize</code> option (<code>isFullsSize() === false</code>), then this will return the <code>radius</code> property (see below), i.e. the radius of the free space inside the ring.<br/>
If the parameter <code>ignoreMargin</code> is truthy, the <code>totalRadius</code> resp. <code>radius</code> will be returned unchanged. Otherwise (especially if no parameter is given), the function will search for a <code>margin</code> property in the <code>contentPluginOptions</code> object and it will subtract this margin from the radius. If no <code>margin</code> property is found, a default margin will be subtracted. In pie mode or with <code>fullSize</code> option set, the default margin is zero (0), in ring mode without <code>fullSize</code> option, the default margin is one (1), i.e. the default radius for a filled circle to be fitted inside a ring graph will leave a margin/gap of 1 pixel between the content background and the ring graph.<br/>
Actually, these two default margins are defined via:

<ul>
<li><code>$.fn.progressPie.defaults.defaultContentPluginBackgroundMarginFullSize: 0</code></li>
<li><code>$.fn.progressPie.defaults.defaultContentPluginBackgroundMarginInsideRing: 1</code>
I.e. you may override these defaults by overwriting those properties of the defaults object.<br/>
Usage hint: If you always want to draw a colored background, you may simply call <code>getBackgroundRadius()</code> without parameters. If, on the other hand, your content plug-in defines an optional property for the background color (let&#8217;s assume, it&#8217;s called <code>backgroundColor</code>) and if your plug-in won&#8217;t draw a filled background for its content, but draw the content directly onto the pie or ring chart if that option is not set, then you might want to ignore the margin option as long as <code>backgroundColor</code> is not set by calling:<br/>
<code>getBackgroundRadius(!opts.backgroundColor);</code> or similar. The conten plug-ins <code>checkComplete</code> and <code>errorIcons</code>, for example, make use of this feature, since the main icon already leaves a free margin to the edge of the filled background and a second margin between the latter and the ring, but without a filled background, these double margins would yield unnecessarily small icons.</li>
</ul></li>
<li><code>addBackground</code>: function(radius): If want to draw something onto a circular filled background, call this method. It takes a number as argument and draws a filled circle with that argument taken as radius. The center of the circle is always the center of the pie. The color for the filled circle has to be defined in the property <code>this.backgroundColor</code>. If this option is falsy (e.g. undefined), the method will not draw anything.<br/>
This method is typically combined with <code>getBackgroundRadius()</code>, i.e. you would usually pass the result of <code>getBackgroundRadius()</code> as argument to this method.<br/>
See the source code of <code>errorIcons.js</code> or <code>checkComplete.js</code> for example usages.</li>
</ul>

<h5 id="propertiesoftheparameterobject">Properties of the parameter object</h5>

<ul>
<li><code>radius</code>: number. If the progressPie plug-in draws a simple pie chart (i.e. option <code>ringWidth</code> is undefined), this is the radius of the pie minus the <code>strokeWidth</code> of the surrounding circle. If <code>ringWidth</code> is set, this is the pie radius minus <code>ringWidth</code>, i.e. the radius of the free space inside the ring. Your content plug-in should base the size of the content it draws on this value.</li>
<li><code>totalRadius</code>: number. This is the overall radius of the whole pie or ring graph including the outer circle stroke. This equals half the width and height of the generated SVG.</li>
<li><code>color</code>: string (color code). By default this is exaclty the color of the pie/ring chart, unless the <code>contentPluginOptions</code> object overrides this.</li>
<li><code>precentValue</code>: number. The value in 0..100 depicted by the progressPie chart.</li>
<li><code>rawValue</code>: string. The raw string defining the value of the pie chart. This may be a percent number or any other value which gets converted into a percent value by a <code>valueAdapter</code> function, see above.</li>
<li><code>pieOpts</code>: object. A reference to the original options object the user passed to the progressPie plug-in. Inside this object you can find, for example, the <code>ringWidth</code> or the <code>strokeWidth</code> option for the outer circle of the pie chart, in case your content plug-in wishes to adapt its own content to some of these pie styles.</li>
</ul>

<p>In addition to these properties, the <code>args</code> object will hold any property the user added to the <code>contentPluginOptions</code> object. If your plug-in should define its own properties (such as the <code>fontSizeFactor</code> option of the Value Display content plug-in described above), simply document these and the user of your content plug-in may insert these options into the <code>contentPluginOptions</code>.</p>

<p>After evaluating these arguments, your <code>draw</code> function may now insert SVG elements (using the <code>newSvgElement</code> function and maybe also <code>newSvgSubelement</code>). For positioning these elements, you need to know the origin of the coordinate system: The point (0, 0) refers to the <em>center of the circle</em>!</p>

<p>As a very simple example, the following function describes a content plug-in which simply draws a filled square inside the ring graph (or on top of a pie graph) in the same color and with a side length which equals the radius of the circle. So, since (0, 0) is the circle&#8217;s center and the square should be circled and radius is the width and height of the square, its top left corner has to be located at the coordinates (-radius/2, -radius/2):</p>

<pre><code>( function($) {
    $.fn.progressPie.contentPlugin.mySquare = {
        draw: function(args) {
            var square = args.newSvgElement(&quot;rect&quot;);
            var topleft = - args.radius / 2;
            square.setAttribute(&quot;x&quot;, topleft);
            square.setAttribute(&quot;y&quot;, topleft);
            square.setAttribute(&quot;width&quot;, args.radius);
            square.setAttribute(&quot;height&quot;, args.radius);
            square.setAttribute(&quot;style&quot;, &quot;fill: &quot; + args.color + &quot;; stroke: none&quot;);
        }
    }
} (jQuery));
</code></pre>

<p>Have a look at the source code of the included content plug-ins for more examples.</p>

<h4 id="thehideschartiffullsizemethod">The <code>hidesChartIfFullSize</code> method</h4>

<p>With the new API, your plug-in may optionally implement a second method (function property) called <code>hidesChartIfFullSize</code>, also taking one argument object as parameter.</p>

<p>If you implement this, it gets called before the actual progressPie chart is drawn (and before the <code>draw</code> method is called).</p>

<p>It gets called only under the following circumstances:</p>

<ul>
<li>the <code>progressPie()</code> jQuery plug-in is used in pie mode, i.e. option <code>ringWidth</code> is <code>undefined</code> <strong>or</strong></li>
<li>the <code>contentPluginOptions</code> include the option <code>fullsize</code> (with a truthy value).</li>
</ul>

<p>I.e. if the user wants to draw a progress ring, to use your content plug-in without a <code>fullsize</code> option, it is assumed that your content plug-in always fits its content into the ring, thus the <code>hidesChartIfFullSize</code> method is never applied.</p>

<p>(See also the <code>isFullSize()</code> function of the <code>draw</code> method&#8217;s arguments object: The latter will return true under the exact same conditions.)</p>

<p>If the above preconditions are met (<code>typeof ringWidth === 'undefined' || contentPluginOptions.fullsize</code>) <em>and</em> your content plug-in&#8217;s <code>hidesChartIfFullSize()</code> method returns <code>true</code> (or any truthy value), then and only then the actual progress pie or ring will not be rendered at all, the content plug-in&#8217;s <code>draw()</code> method will be called and will be the only code generating SVG content.</p>

<p><em>So what is this good for?</em></p>

<p>A typical application of suppressing the rendering of the actual chart is any case where the content plug-in&#8217;s output would completely cover/occlude the chart anyway (typically by calling <code>args.addBackgound(args.getBackgroundRadius())</code> with the aforementioned <code>fullsize</code> option or in pie mode). In this case, this mainly keeps the generated SVG slimmer (why render output that will always stay invisible?). But there is also another effect: Assume your pie chart would be drawn in a rather dark color (black, navy, …) and a content plug-in (e.g. the <code>exclamationMark</code> plug-in) adds a rather light (e.g. yellow) filled circle on top of that, then this light disc should cover the dark pie completely—theoretically. But practically, probably due to anti-aliasing of the circle&#8217;s outlines, most browsers would actually show a slight dark edge around the light disc, a sort of unwanted halo effect. This was visible with Version 1 of the progressPie plug-in and its included checkComplete-, error- and exclamationMark content plug-ins and was addressed by adapting these content plug-ins to this new API.</p>

<p><em>How should the method be implemented?</em></p>

<p>Usually you should make sure to only return true (and thus eliminate the actual chart completely) if you are absolutely sure, your <code>draw</code> method would otherwise completely occlude the chart anyway (except for the potential &#8216;halo&#8217;). Have a look at the content plug-ins <code>error</code> and <code>exclamationMark</code> in <code>jquery-progresspiesvg-errorIcons.js</code>: These check, that the user really configured a background color and that the color code does not start with <code>rgba</code> (in which case it would probably draw a semi-transparent background not completely occluding the chart). Also they check that no <code>margin</code> option is set which would reduce the size of the configured background and leave some of the chart visible.</p>

<p>The <code>warning</code> conten plug-in in the same file is a different example: The triangular warning sign will never completely occlude a circular chart, but this plug-in explicitly introduces an option for the user to configure whether he wants his warning sign to be a layer on top of the chart or whether he wants the warning sign alone, without a chart in the background.</p>

<h5 id="propertiesoftheparameterobject">Properties of the parameter object</h5>

<p>The <code>hidesChartIfFullSize</code> method also takes a parameter argument with information probably needed to decide whether to answer with true or false.</p>

<p>Since this method is called earlier in the whole process than the <code>draw</code> method is, it gets only a subset of the information (properties), also the methods of the <code>draw</code> method&#8217;s parameter are neither available nor needed here.</p>

<p>The following properties are passed to the <code>hidesChartIfFullSize</code> method (as properties of its sole parameter):</p>

<ul>
<li><code>color</code></li>
<li><code>percentValue</code></li>
<li><code>rawValue</code></li>
<li><code>pieOpts</code></li>
<li>plus every option defined by the user in <code>contentPluginOptions</code>.</li>
</ul>

<p>The semantics of these properties are the same as in the <code>draw</code> methods argument, see above.</p>

<h2 id="license:bsd2-clause">License: BSD 2-clause</h2>

<p>Copyright (c) 2015, Immo Schulz-Gerlach, www.isg-software.de<br/>
All rights reserved.</p>

<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p>

<ol>
<li><p>Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</p></li>
<li><p>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</p></li>
</ol>

<p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &#8220;AS IS&#8221; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>

</body>
</html>
